In this project I:

- Created a graph of relationships among chess squares (based on what neighboring locations a knight piece could legally move to)
- Develop an algorithm which produces all the possible paths a knight could take after 1, 2, 3, 4, 5, and 6 moves from a given start location, without ever moving back to the same square it was just previously on
- Develop a method to traverse the tree of paths produces in a semi-bfs manner

- This project was really challenging for me. The result I came up with may not perfectly execute a truly-bfs algorithm, however this was the best solution I could come up with. I could not wrap my mind around how I would keep all the different possible paths straight while using a queue system. This algorithm completes all stated requirements, and for the moment that is the best I can do.
